

import {checkFieldsValidity} from '../requests/helpers.js';

// also NEED write generateSubtasksForIssue() method.


const { GoogleGenerativeAI } = require("@google/generative-ai"); // import

const API_KEY = 'AIzaSyCOg-SHfvbdK_phTbeoW3faeeO-N9QPIgw'
const genAI = new GoogleGenerativeAI(API_KEY);
const model = genAI.getGenerativeModel({ model: "gemini-pro"});



/**
 *  Fetches model info.
 *
 *  Model info is object with such [structure](https://ai.google.dev/api/rest/v1/models).
 *
 * This method uses the corresponding API [endpoint](https://ai.google.dev/api/rest/v1/models/get).
 * The `model` parameter of endpoint's request can be taken from `GenerativeModel.model` property.
 * Btw, `GenerativeModel.model` equals to returned object's `name` property.
 * @return {Promise<any>}
 */
export const fetchModelInfo = async() => {
  const response = await fetch(`https://generativelanguage.googleapis.com/v1/${model.model}?key=${API_KEY}`);
  return await response.json();
}

/**
 * Counts number of tokens in the provided `prompt`.
 * Note, that 100 tokens is approximately 60-70 words of natural human text.
 *
 * This method uses `GenerativeModel.countTokens()` method
 * @param prompt
 * @return {Promise<number>}
 */
const countNumberOfTokens = async (prompt) => {
  const result = await model.countTokens(prompt);
  return result.totalTokens;
}

/**
 * Template method for getting text answers from Gemini.
 *
 * It is supposed to be used by other methods simply by passing the `prompt` parameter.
 * @param prompt
 * @return object `{ok, answer, errorMessage}`.
 *
 *
 * `ok` shows whether answer from Gemini received successfully or not;
 *
 * `answer` (when `ok === true`) is text (`string`) of response returned by Gemini;
 *
 * `errorMessage` (when `ok === false`) is user-friendly text of error.
 */
const getAnswerFromGemini = async(prompt) => {
  try{
    const modelInfo = await fetchModelInfo();

    // check if prompt is too long
    const modelInputTokenLimit = modelInfo.inputTokenLimit;
    const numberOfTokens = await countNumberOfTokens(prompt);
    if(numberOfTokens > modelInputTokenLimit){
      return {ok: false, errorMessage: `Sorry, but query is too large and LLM can't process it.\
    Your query is ${numberOfTokens} tokens but model's limit is ${modelInputTokenLimit}.`};
    }

    // send prompt to Gemini and get answer
    const result = await model.generateContent(prompt);
    const response = result.response;

    return {ok: true, answer: response.text()};
  }
  catch(e){ // GoogleGenerativeAIError
    console.log(`Error: ${e}`);
    return {ok: false, errorMessage: 'Something wrong happened. Try again.'};
  }
}



/**
 * Generates subtasks for issue using Gemini API.
 * @see "generate-tasks.hbs" file to see format of expected answer
 * @param prompt is prompt that will be sent to Gemini.
 * @return object `{ok, answer, errorMessage}`.
 *
 *
 * `ok` shows whether answer from Gemini received successfully or not and whether received answer is valid;
 *
 * `answer` (when `ok === true`) is array of generated subtasks - objects `{task, description}`;
 *
 * `errorMessage` (when `ok === false`) is user-friendly text of error.
 */
export const generateSubtasksForIssue = async(prompt) => {
  const result = await getAnswerFromGemini(prompt);

  if(!result.ok){ // if error occurred
    return result;
  }

  // parse text generated by Gemini
  try{
    const arr = JSON.parse(result.answer);
    if(!Array.isArray(arr)){
      return {ok: false, errorMessage: 'Something wrong happened. Try again.'};
    }

    // filter each array element
    let subtaskNecessaryFields = [
      {field: "task", type: "string"},
      {field: "description", type: "string"},
    ];
    let subtasks = [];
    for (const arrItem of arr){
      if(checkFieldsValidity(arrItem, subtaskNecessaryFields)){ // check if each expected field is present and has correct type
        // include only expected properties (do not include redundant properties that Gemini can generate by mistake)
        subtasks.push({task: arrItem.task, description: arrItem.description});
      }
      // otherwise, do not include current arrItem in result
    }

    return {ok: true, answer: subtasks};
  }
  catch(e){ // if result.answer is not an object
    return {ok: false, errorMessage: 'Something wrong happened. Try again.'};
  }
}